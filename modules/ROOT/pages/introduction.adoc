= Lisk Core Documentation
Mona Bärenfänger <mona@lightcurve.io>
:toc:
:imagesdir: ../assets/images

ifeval::[{page-component-version} !== master]
IMPORTANT: There is a newer version out for Lisk Core. xref:master@{page-component-name}::index.adoc[Click here], to jump to the documentation for the latest Lisk Core version.
endif::[]

https://www.youtube.com/watch?v=RfF9EPwQDOY[image:https://img.youtube.com/vi/RfF9EPwQDOY/0.jpg[What is Lisk Core?]]

Lisk Core is the program that implements the
xref:1.1@lisk-protocol::introduction.adoc[Lisk Protocol]. Every machine must
set it up to run a node that allows for participation in the network.
Setting up Lisk Core enables a user to:

* Connect to a <<_networks,Network>> and communicate with other nodes
in the network.
* Full control to xref:configuration.adoc[configure] Lisk Core to specific
needs, as required.
* Create your own <<_snapshots,snapshots>> of the blockchain.
* Use Lisk Core to perform actions on the Lisk blockchain, e.g. with
https://github.com/LiskHQ/lisk-docs/blob/master/lisk-hub/introduction.md#network-switcher[Lisk
Hub].
* xref:configuration.adoc#_forging[Forge] new blocks (if you are an active
delegate).

By setting up your node, you contribute to the decentralization of the
Lisk network.

An instance of Lisk Core is generally detailed in two different ways:

____
A Lisk Core instance connected to a network is referred to as a Lisk
*Node*. A Lisk Node connected to other Lisk Nodes is referred to as a
Lisk *Peer*.
____

Both meanings refer to a machine which, after installing and executing
Lisk Core, become a server. The server participates in the network and
provides blockchain data to its clients.

== Versions

We release new versions of Lisk Core regularly. Documentation on
https://lisk.io/documentation[lisk.io] will keep up to date with version
updates. The Lisk Core version reference below provides an overview of
the former releases and documentation versions of Lisk Core.

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Software Version |Protocol Version |Release date (yy/mm/dd)
|Documentation reference
|https://github.com/LiskHQ/lisk-sdk/releases/tag/v1.6.0[v1.6.0] |1.0
|19/04/24 |_Current version, live on lisk.io/documentation_

|https://github.com/LiskHQ/lisk-sdk/releases/tag/v1.5.1[v1.5.1] |1.0
|19/04/10
|https://github.com/LiskHQ/lisk-docs/blob/core-1.4.0/introduction.md[Lisk
Core 1.5 docs]

|https://github.com/LiskHQ/lisk-sdk/releases/tag/v1.4.1[v1.4.1] |1.0
|19/02/14
|https://github.com/LiskHQ/lisk-docs/blob/core-1.4.0/introduction.md[Lisk
Core 1.4 docs]

|https://github.com/LiskHQ/lisk-sdk/releases/tag/v1.3.1[v1.3.1] |1.0
|18/12/05
|https://github.com/LiskHQ/lisk-docs/blob/core-1.3.0/introduction.md[Lisk
Core 1.3 docs]

|https://github.com/LiskHQ/lisk-sdk/releases/tag/v1.2.1[v1.2.1] |1.0
|18/11/10
|https://github.com/LiskHQ/lisk-docs/blob/core-1.2.0/introduction.md[Lisk
Core 1.2 docs]

|https://github.com/LiskHQ/lisk-sdk/releases/tag/v1.1.1[v1.1.1] |1.0
|18/10/23
|https://github.com/LiskHQ/lisk-docs/blob/core-1.1.0/introduction.md[Lisk
Core 1.1 docs]

|https://github.com/LiskHQ/lisk-sdk/releases/tag/v1.0.3[v1.0.3] |1.0
|18/08/17
|https://github.com/LiskHQ/lisk-docs/blob/core-1.0.0/introduction.md[Lisk
Core 1.0 docs]
|===

== Versioning schemes

Lisk Core is described in 2 different versioning schemes. The *Software
Implementation Version* and the *Protocol Version*.

=== Software implementation versioning

Any Lisk Core software changes, except for the logging system, are
communicated following the exact rules specified by
https://semver.org/[SemVer].

Software implementation versioning has a version prefix `+v+` followed
by a 3 digit notation `+<MAJOR>.<MINOR>.<PATCH>+` , where the individual
digits represent the following types of software changes:

....
v<MAJOR>.<MINOR>.<PATCH>

v     - Version prefix
MAJOR - Breaking change
MINOR - New feature
PATCH - Bug fix
....

The _software implementation version_ follows the popular SemVer scheme
and gives a quick overview for developers about breaking and
non-breaking changes in the software.

=== Protocol versioning

The _protocol version_ is denoted by two digits, `+H.S.+`. The first
digit, `+H+`, depends on the number of hard forks and is incremented
with every hard fork. `+S+` represents the number of soft forks since
the last hard fork.

____
The initial protocol version 1.0 is defined to be the one that was
implemented by Lisk Core v1.0.0.
____

The _protocol version_ is used e.g. in P2P Communication between Lisk
Core nodes, to determine, if the nodes have compatible versions of the
Lisk protocol implemented.

== Upgrade vs Migration

When to upgrade, when to migrate Lisk Core?

Every time that a new software update of Lisk Core introduces a *hard
fork* on the network, you need to xref:migration.adoc[migrate] your
existing Lisk Core version.

In all other cases, you can use the normal *upgrade* process, according
to the distribution you are using:

* xref:upgrade/binary.adoc[Upgrade Lisk Core Binary]
* xref:upgrade/docker.adoc[Upgrade Lisk Core Docker]
* xref:upgrade/source.adoc[Upgrade Lisk Core Source]

== Networks

Lisk Core can be connected to different networks. There are two key
public networks, entirely independent of each other, that are always
accessible: *Mainnet* and *Testnet*.

=== Mainnet

Mainnet is where the true Lisk economy exists. On this network, Lisk
users can transfer LSK tokens from one account to another, register
accounts as delegates, vote for other delegates or register dApps. It
can be explored via the https://explorer.lisk.io[Lisk Explorer].

=== Testnet

Testnet is an independent replica of the Lisk Mainnet intended as an
area to rehearse upgrades before they take place on the Lisk Mainnet.
This is where new versions and fixes of Lisk Core are tested. It can be
explored via https://testnet-explorer.lisk.io[Lisk Testnet Explorer].

== Distributions

The 3 supported distributions for Lisk Core are presented below:

=== link:setup/binary.md[Binary]

The *default* way to setup Lisk Core. The binary installation is an easy
and automated way to set up Lisk Core, this includes nearly completely
automated update scripts and a selection of tools to help seamlessly
maintain a Lisk Node.

=== link:setup/docker.md[Docker]

Docker adds support for additional platforms upon which to run a Lisk
node, e.g. running a Lisk node inside of a Docker on Windows and
connecting it via a custom Node on Lisk Hub to Lisk Core, without the
need to rent an additional server.

=== link:setup/source.md[Source]

This is made for anyone wishing to develop on the Lisk Core codebase. It
also comes with an extensive test-suite, detailed in `+README.md+`.
Installation from Source enables a developer to work on the newest
codebase for Lisk Core, which might not have been tagged for a release,
yet.

== Snapshots

A snapshot is a backup of the complete blockchain. It can be used to
speed up the sync process, instead of having to validate all
transactions starting from genesis block to current block height. Lisk
provides official snapshots of the blockchain, see
http://snapshots.lisk.io.

How to rebuild from a snapshot, and how to create your own snapshots is
explained in the Administration section for each
<<_distributions,distribution>> of Lisk Core.

____
We recommend using link:administration/binary.md#create-snapshot[Lisk
Core Binary] for creating own snapshots, as it provides a script to
create snapshots most convenience.
____

== Architecture

Lisk Core utilizes the Lisk Framework and its’ modules and components,
to set up a Lisk node. The Lisk Framework offers some core-specific
modules for this purpose. A simplified overview of the architecture of
the Lisk Framework:

image:diagram_framework.png[Lisk-Framework]

=== Modules

Modules are individual building blocks for Lisk Core.

==== Core Modules

Core Modules are shipped along with the Lisk Core distribution itself.
These modules constitute the minimum requirements to run a functional
Lisk Core instance.

===== List of Core Modules

* *Chain Module:* handles all events and actions, that are related to
the blockchain system.
* *HTTP API Module:* provides API endpoints, that enable users and other
programs to communicate with the Lisk blockchain through the API.

==== Custom Modules

____
The implementation of each module is up-to user but it must inherit from
`+BaseModule+` class and implement its methods.
____

Custom Modules can be plugged into Lisk Core and may offer new
features/capabilities for the application, or replace Core modules
functionalities. They extend the existing instance with a specific (and
circumscribed) set of features.

[source,js]
----
// Exported as main file to javascript package
export default class MyModule extends BaseModule {
    /**
    * Constructor of the module.
    *
     * @param {Object} options - An object of module options
    */
    constructor(options) {
     super(options);
    }

    /**
    * Required.
    *
    * A unique module identifier, that can be accessed through out the system.
    * If some module already registered with the same alias, it will throw an error.
    *
    * @return {string} alias - Return the module alias as string.
    * */
    static get alias(){ return 'moduleAlias'; },

    /**
    * Required.
    *
    * Package meta information.
    *
    * @return {Object} info - JSON object referring the version, module name and module author.
    */
    static get info(){
        return {
            author: '',
            version: '',
            name: '',
            };
    },

    /**
    * Required.
    *
    * Method which will be invoked by controller to load the module.
    * Make sure all loading logic get completed during the life cycle of load.
    * Controller emit an event `lisk:ready` which you can use to perform
    * some activities which you want to perform when every other module is loaded.
    *
    * @param {Channel} channel - An instance of a communication channel.
    * @return {Promise<void>}
    */
    async load(channel) {},


    /**
     * Supported configurations for the module with default values.
     *
     * @return {Object} defaults - JSON object with default options for the module.
     */
    get defaults() { return {}; },

    /**
     * List of valid events which this module wants to register with the controller.
     * Each event name will be prefixed by module alias, e.g. moduleName:event1.
     * Listing an event means to register the event in the application.
     * Any module can subscribe or publish that event in the application.
     *
     * @return {Array} events - String Array of events.
     */
    get events() { return []; },

    /**
     * Object of valid actions which this module want to register with the controller.
     * Each action name will be prefixed by module alias, e.g. moduleName:action1.
     * Source module can define the action while others can invoke that action.
     *
     * @return {Object} actions - Contains all available action names as key, and the corresponding function as value.
     */
    get actions() {
        return {
            action1: action => {},
        }
    },

    /**
     * Method to be invoked by controller to perform the cleanup.
     *
     * @return {Promise<void>}
     */
    async unload() {},
};
----

==== Module Communication

Modules communicate with each other through event-based
link:#channels[channels]. Modules running in different processes
communicate with each other over link:#child-process-channel[IPC
channels].

By default, modules will run in the same process as the controller,
which loads the module. To load a module in a child process, make sure
you have `+ipc+` enabled in the xref:configuration.adoc#_structure[config]
file and xref:administration/source.adoc#_command_line_options[set theenvironment variable] `+LISK_CHILD_PROCESS_MODULES+` with the module
alias.

____
If the respective module is using a lot of CPU power, loading a module
in a child process can prevent CPU usage bottlenecks.
____

Multiple modules can be defined by using commas like:
`+LISK_CHILD_PROCESS_MODULES=httpApi,chain+`.

The following methods are available for every module to use:

===== `+subscribe+`

Used to subscribe to events occurring on the controller.

[source,js]
----
channel.subscribe("moduleAlias:someEvent", eventObject => {});
----

This function accepts two arguments. The first is the event name
prefixed with the name of the relevant module. The second argument is a
callback which accepts one argument, which will be an instance of an
<<_specification_channels_event,event object>>.

===== `+publish+`

Used to publish events to the controller, which will be delivered to all
events subscribers.

[source,js]
----
channel.publish('myModule:myContext:myEvent', eventObject);
----

This function accepts two arguments. The first one is the event name
prefixed with the name of the relevant module. The second argument is
the data object to be passed along the event.

===== `+invoke+`

Used to invoke an action for a module.

[source,js]
----
result = await channel.invoke('moduleAlias:someEvent', actionObject);
----

This function accepts two arguments. The first one is the event name
prefixed with the name of the relevant module. The second argument is
the data object to be passed along the action.

===== Event objects

An event object is a simple JavaScript object with the following
attributes.

[cols=",,",options="header",]
|===
|Property |Type |Description
|name |string |The name of the event which is triggered.

|module |string |The name of the target module for which event was
triggered.

|source |string |The name of source module which published that event.

|data |mixed |The data which was sent while publishing the event.
|===

===== Action objects

An action object is a simple javascript object with attributes listed
below.

[width="100%",cols="11%,7%,82%",options="header",]
|===
|Property |Type |Description
|name |string |Name of the action which is invoked.

|module |string |The name of the target module for which action was
invoked.

|source |string |The name of source module which invoked that action.

|params |mixed |The data which was associated with the invocation for
the action.
|===

==== Module Life Cycle

The <<_controller,controller>> will load/unload each module one after
another. A modules’ life cycle consists of following events in the right
order:

*Loading*

* `+channel.moduleAlias:registeredToBus+`
* `+channel.moduleAlias:loading:started+`
* `+channel.moduleAlias:loading:finished+`

*Unloading*

* `+channel.moduleAlias:unloading:started+`
* `+channel.moduleAlias:unloading:finished+`

=== Channels

==== InMemory Channel

Communicates with modules which reside in the same process as the
<<_controller,controller>>.

By default, modules will load in the same process as the controller.

==== Child Process Channel

Communicates with modules which do not reside in the same process as the
Controller.

=== Controller

The controller is a parent process, that is responsible for managing
every user interaction with each <<_components,component>> and
<<_modules,module>> of the framework. E.g. restarting the node,
starting a snapshot process, etc.

The controller is responsible for initialization of the
infrastructure-level components. The controller also initializes each
module separately. If any module is configured to load as a child
process, then it is the controller’s responsibility to do so. The
controller defines a set of events, that each component can subscribe
to:

The following events and actions are available for all enabled modules
and are at the same time accessible by all enabled modules.

==== Events

____
Each module can also define its own custom events or actions and will
register that list with the controller at the time of initialization.
The controller contains a complete list of events which may occur in the
modules of Lisk Core at any given time.
____

[width="100%",cols="11%,89%",options="header",]
|===
|Event |Description
|moduleAlias:registeredToBus |Triggered when the module has completed
registering its events and actions with the controller. So when this
event is triggered, the subscriber of the event can be sure that the
controller has whitelisted its requested events and actions.

|moduleAlias:loading:started |Triggered just before the controller calls
the module’s `+load+` method.

|moduleAlias:loading:error |Triggered if any error occurred during the
call of the module’s `+load+` method.

|moduleAlias:loading:finished |Triggered just after the module’s
`+load+` method has completed execution.

|moduleAlias:unloading:started |Triggered just before the controller
calls the module’s `+unload+` method.

|moduleAlias:unloading:error |Triggered if any error occurred during the
call of module’s `+unload+` method.

|moduleAlias:unloading:finished |Triggered just after the module’s
`+unload+` method has completed execution.

|lisk:ready |Triggered when the controller has finished initializing the
modules and each module has been successfully loaded.
|===

==== Actions

[width="100%",cols="21%,79%",options="header",]
|===
|Action |Description
|lisk:getComponentConfig |A controller action to get the configuration
of any component defined in controller space.
|===

=== Components

Components are shared objects within the <<_controller,controller>>
layer which any <<_modules,module>> can utilize. Components can use
<<_channels,channels>> if required for implementation behavior. The
following components are available currently.

==== Cache

This component provides basic caching capabilities, generic enough for
any module to use if required.

==== Logger

Logger is responsible for all application-level logging activity. The
logger component can be passed to any module, where it can be extended
by adding module-specific behaviour.

==== Storage

The storage component is responsible for all database activity in the
system. It exposes an interface with specific features for getting or
setting particular database entities and a raw handler to the database
object so that any module can extend it for its own use.

Find more details about the storage component in the dedicated
https://github.com/LiskHQ/lips/blob/master/proposals/lip-0011.md[LIP].

==== System

The system component provides per-module system information. Each module
is responsible for keeping the information up-to-date.

It holds the variables and constants critical for the whole application,
possibly affecting other modules. For now, those are: ``os'',
``version'', ``wsPort'', ``httpPort'', ``minVersion'',
``protocolVersion'', ``height'', ``nethash'', ``broadhash'' and
``nonce''.

== Technology stack

The Lisk Core consists of 4 main technologies:

https://nodejs.org[image:assets/nodejs.png[Node.js,title="Node.js"]]

https://nodejs.org/[Node.js] serves as the underlying engine for code
execution in Lisk Core. Node.js is an open-source, cross-platform
JavaScript run-time environment that executes JavaScript code
server-side. Node.js uses an event-driven, non-blocking I/O model that
makes it lightweight and efficient.

https://swagger.io[image:assets/swagger-logo.png[Swagger,title="Swagger"]]

https://swagger.io[Swagger] is an open source software framework backed
by a large ecosystem of tools that helps developers design, build,
document, and consume RESTful Web services. As part of the Lisk Core
documentation, the whole API specification can be explored interactively
via the Swagger-UI interface.

https://www.postgresql.org[image:assets/postgresql.png[PostgreSQL,title="PostgreSQL"]]

https://www.postgresql.org[PostgreSQL] is a powerful, open source
object-relational database system with over 30 years of active
development which has earned it a strong reputation for reliability,
feature robustness, and performance. All Information on the Lisk
mainchain is stored inside of PostgreSQL databases.

https://redis.io[image:assets/redis.png[Redis,title="Swagger"]]

https://redis.io[Redis] is an open source, in-memory data structure
store. Lisk Core mainly uses it to cache API responses. This prevents
performance drops in the application, for example when the same API
request is sent repeatedly.

== Contribute to the Codebase

Everyone is invited to contribute to the Lisk Core project. We welcome
and appreciate all contributions.

=== Github

All necessary information can be found on our
https://github.com/LiskHQ/lisk-sdk[Lisk SDK Github].

=== Contribution Guidelines

Please be sure to read and follow our
https://github.com/LiskHQ/lisk-sdk/blob/development/docs/CONTRIBUTING.md[Contribution
Guidelines].

=== Gitter

If you have any further questions please join our
https://gitter.im/LiskHQ/lisk[Gitter].
